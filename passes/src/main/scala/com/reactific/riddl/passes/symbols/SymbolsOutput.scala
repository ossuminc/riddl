/*
 * Copyright 2019 Ossum, Inc.
 *
 * SPDX-License-Identifier: Apache-2.0
 */

package com.reactific.riddl.passes.symbols

import com.reactific.riddl.language.AST.*
import com.reactific.riddl.language.Messages
import com.reactific.riddl.passes.PassOutput
import com.reactific.riddl.passes.symbols.Symbols.{Parentage, SymTab}

import scala.annotation.tailrec
import scala.collection.mutable
import scala.reflect.{ClassTag, classTag}

object Symbols {
  type Parents = Seq[Definition]
  type Parentage = mutable.HashMap[Definition, Parents]
  type SymTabItem = (Definition, Parents)
  type SymTab = mutable.HashMap[String, Seq[SymTabItem]]

  val emptySymTab = mutable.HashMap.empty[String, Seq[SymTabItem]]
  val emptyParentage = mutable.HashMap.empty[Definition, Parents]
}

/** Output from the Symbols Pass
  * @param messages
  *   The error messages generated by the pass
  * @param symTab
  *   The SymbolTable that handles identifier translation to definitions
  */
case class SymbolsOutput(
  messages: Messages.Messages = Messages.empty,
  symTab: SymTab = Symbols.emptySymTab,
  parentage: Parentage = Symbols.emptyParentage
) extends PassOutput {

  /** Get the parent of a definition
    *
    * @param definition
    *   The definition whose parent is to be sought.
    * @return
    *   optionally, the parent definition of the given definition
    */
  def parentOf(definition: Definition): Option[Definition] =
    parentage.get(definition) match {
      case Some(container) => container.headOption
      case None            => None
    }

  /** Get all parents of a definition
    *
    * @param definition
    *   The defintiion whose parents are to be sought.
    * @return
    *   the sequence of ParentDefOf parents or empty if none.
    */
  def parentsOf(definition: Definition): Seq[Definition] = {
    parentage.get(definition) match {
      case Some(list) => list
      case None       => Seq.empty[Definition]
    }
  }

  def contextOf(definition: Definition): Option[Context] = {
    val tail = parentsOf(definition).dropWhile(_.getClass != classOf[Context])
    tail.headOption.asInstanceOf[Option[Context]]
  }

  /** Get the full path of a definition
    *
    * @param definition
    *   The definition for which the path name is sought.
    * @return
    *   A list of strings from leaf to root giving the names of the definition and its parents.
    */
  def pathOf(definition: Definition): Seq[String] = {
    definition.id.value +: parentsOf(definition).map(_.id.value)
  }

  private def hasSameParentNames(id: Seq[String], parents: Symbols.Parents): Boolean = {
    val containerNames = id.drop(1)
    val parentNames = parents.map(_.id.value)
    containerNames.zip(parentNames).forall { case (containerName, parentName) =>
      containerName == parentName
    }
  }

  /** The result of a lookupSymbol request A lookupSymbol request returns a list of tuples that contain the generic
    * definition, as a Definition, and, if the definition matches the type of interest, D, then an Option[D] for
    * convenience.
    */
  type LookupResult[D <: Definition] = List[(Definition, Option[D])]

  /** Look up a symbol in the table
    *
    * @param id
    *   The multi-part identifier of the symbol, from leaf to root, that is from most nested to least nested.
    * @tparam D
    *   The expected type of definition
    * @return
    *   A list of matching definitions of 2-tuples giving the definition as a Definition type and optionally as the
    *   requested type
    */
  def lookupSymbol[D <: Definition: ClassTag](
    id: Seq[String]
  ): LookupResult[D] = {
    require(id.nonEmpty, "No name elements provided to lookupSymbol")
    val clazz = classTag[D].runtimeClass
    val nameList = id.reverse
    nameList.headOption match
      case None =>
        List.empty
      case Some(leafName) =>
        symTab.get(leafName) match {
          case Some(set) =>
            set
              .filter { case (_: Definition, parents: Seq[Definition]) =>
                // whittle down the list of matches to the ones whose parents names
                // have the same as the nameList provided
                hasSameParentNames(nameList, parents)
              }
              .map { case (d: Definition, _: Seq[Definition]) =>
                // If a name match is also the same type as desired by the caller
                // then give them the definition in the requested type, optionally
                if clazz.isInstance(d) then { (d, Option(d.asInstanceOf[D])) }
                else { (d, None) }
              }
              .toList
          case None =>
            // Symbol wasn't found
            List.empty
        }
  }

  /** Look up a symbol in the table
    *
    * @param names
    *   The multi-part identifier of the symbol, from leaf to root, that is from most nested to least nested.
    * @return
    *   A list of matching definitions of 2-tuples giving the definition as a Definition type and optionally as the
    *   requested type
    */
  def lookupParentage(
    names: Seq[String]
  ): List[Symbols.SymTabItem] = {
    names.headOption match
      case None =>
        require(names.nonEmpty, "No name elements provided to lookupSymbol")
        List.empty[Symbols.SymTabItem]
      case Some(leafName) =>
        symTab.get(leafName) match {
          case Some(set) =>
            set.filter { case (_: Definition, parents: Seq[Definition]) =>
              // whittle down the list of matches to the ones whose parents names
              // have the same as the nameList provided
              hasSameParentNames(names, parents)
            }.toList
          case None =>
            // Symbol wasn't found
            List.empty[Symbols.SymTabItem]
        }
  }

  def lookup[D <: Definition: ClassTag](
    ref: Reference[D]
  ): List[D] = { lookup[D](ref.pathId.value) }

  def lookup[D <: Definition: ClassTag](
    id: Seq[String]
  ): List[D] = {
    val clazz = classTag[D].runtimeClass
    id.headOption match
      case None =>
        require(id.nonEmpty, "Provided id is empty")
        List.empty[D]
      case Some(leafName) =>
        symTab.get(leafName) match {
          case Some(set) =>
            val result = set
              .filter { case (d: Definition, parents: Symbols.Parents) =>
                if clazz.isInstance(d) then {
                  // It is in the result set as long as the container names
                  // given in the provided id are the same as the container
                  // names in the symbol table.
                  hasSameParentNames(id, parents)
                } else { false }
              }
              .map(_._1.asInstanceOf[D])
            result.toList
          case None => List.empty[D]
        }
  }

  def foreachOverloadedSymbol(process: Seq[Seq[Definition]] => Unit): Unit = {
    val overloads = symTab.filterNot(_._1.isEmpty).filter(_._2.size > 1)
    val defs = overloads.toSeq.map(_._2).map(_.map(_._1).toSeq)
    process(defs)
  }

  /** A Filter function for the result set of a lookup on the symtab */
  def entryWithSameParentsAndType(
    expectedClass: Class[?],
    result: Symbols.SymTabItem,
    parents: Seq[Definition]
  ): Boolean = {
    result._1.getClass == expectedClass && result._2 == parents
  }

  private def candidatesFromPid[T <: Definition: ClassTag](
    pid: PathIdentifier,
    parents: Symbols.Parents
  ): Seq[Definition] = {
    // Recursively resolve this PathIdentifier
    val path = resolvePathId[T](pid, parents)
    path.headOption match
      case None =>
        Seq.empty[Definition]
      case Some((head: Definition, parents: Symbols.Parents)) =>
        findCandidates(head, parents.drop(1))
  }

  private def candidatesFromTypeEx(typEx: TypeExpression, parents: Symbols.Parents): Seq[Definition] = {
    typEx match {
      case a: Aggregation =>
        // if we're at a field composed of more fields, then those fields
        // what we are looking for
        a.contents
      case Enumeration(_, enumerators) =>
        // if we're at an enumeration type then the numerators are candidates
        enumerators
      case a: AggregateUseCaseTypeExpression =>
        // Any kind of Aggregate's fields are candidates for resolution
        a.contents
      case AliasedTypeExpression(_, pid) =>
        // if we're at a field that references another type then the candidates
        // are that type's fields. To solve this we need to push
        // that type's path on the name stack to be resolved
        candidatesFromPid[Type](pid, parents)
      case EntityReferenceTypeExpression(_, entityRef) =>
        candidatesFromPid[Entity](entityRef, parents)
      case _ =>
        // We cannot descend into any other type expression
        Seq.empty[Definition]
    }
  }

  def findCandidates(node: Definition, parents: Symbols.Parents): Seq[Definition] = {
    node match
      case st: State =>
        // If we're at a state definition then it references a type for
        // its fields
        candidatesFromPid[Type](st.typ.pathId, parents)
      case oc: OnMessageClause =>
        // if we're at an onClause that references a named message then we
        // need to push that message's path on the name stack
        candidatesFromPid[Type](oc.msg.pathId, parents)
      case field: Field =>
        candidatesFromTypeEx(field.typeEx, parents)
      case c: Constant =>
        candidatesFromTypeEx(c.typeEx, parents)
      case t: Type =>
        candidatesFromTypeEx(t.typ, parents)
      case func: Function =>
        val inputs: Aggregation = func.input.getOrElse(Aggregation.empty())
        val outputs: Aggregation = func.output.getOrElse(Aggregation.empty())
        // If we're at a Function node, the functions input parameters
        // are the candidates to search next
        inputs.contents ++ outputs.contents
      case d: Definition =>
        d.contents.flatMap {
          case Include(_, contents, _) =>
            contents
          case d: Definition =>
            Seq(d)
        }
  }

  @tailrec
  private final def findContainedNodes(
    node: Definition,
    names: Seq[String],
    result: mutable.Stack[Definition]
  ): Boolean = {
    names.headOption match
      case None =>
        true // we're done recursing
      case Some(name) =>
        val candidates = findCandidates(node, result.toSeq)
        candidates.find(_.id.value == name) match
          case None =>
            false // name didn't match
          case Some(subNode) =>
            result.push(subNode) // matched one, recurse to keep going
            findContainedNodes(subNode, names.drop(1), result)
  }

  /** Given a path identifier, try to resolve it in the symbol table to a specific definition. The idea is that an
    * element above the leaf element in the pathId should match an element in the parents stack. Find this element and
    * then use the pathId names of any intervening elments and see if that exists in
    * @param pathId
    *   Contains a sequence of namnes to find, reverse order that the symbol table uses (leaf to root), that is from
    *   root to leaf
    * @param parents
    *   The stack of parents where the pathId occurs, providing the referential context back to the root.
    */
  def resolvePathId[T <: Definition: ClassTag](
    pathId: PathIdentifier,
    parents: Symbols.Parents
  ): Seq[Symbols.SymTabItem] = {
    pathId.value.headOption match
      case None =>
        // The path has no content, can't resolve this
        Seq.empty[Symbols.SymTabItem]
      case Some(anchor) =>
        // The anchor is the highest level name in the pathId and therefore the
        // one we want to search for in the parents so we can construct the
        // path to the sought element

        // Reverse the pathId's names so the leaf is first
        val pathNames = pathId.value.reverse

        // Get that soughtName
        pathNames.headOption match
          case None =>
            // This is a bit redundant, the pathId is empty, fail
            Seq.empty[Symbols.SymTabItem]
          case Some(soughtName) =>
            val newParents: Symbols.Parents = {
              if soughtName == anchor then
                // If the soughtName and the anchor are the same then it just
                // means the pathId refers to the immediately enclosing thing
                parents
              else {
                // In this case, there is more than one name in the path and
                // we need to find the anchor name in the parents in order
                // to construct the parentPath

                // First, get the anchor node from the parents
                parents.find(_.id.value == anchor) match
                  case None =>
                    // Nope, didn't find that name in the parents
                    Seq.empty[Definition]
                  case Some(anchorNode) =>
                    // Next, get the prefix to the anchor
                    val parentPrefix = parents.dropWhile(_.id.value != anchor)

                    // Load the result stack with the parent prefix
                    val result: mutable.Stack[Definition] = new mutable.Stack
                    result.pushAll(parentPrefix.reverse)

                    // Now, search the anchor node for the remainder of the pathNames
                    if findContainedNodes(anchorNode, pathNames.reverse.drop(1), result) then
                      // get the parents to seek
                      result.toSeq.reverse
                    else Seq.empty[Definition]
              }
            }

            // We finally have the new parents to match against, check for empty
            if newParents.isEmpty then Seq.empty[Symbols.SymTabItem]
            else
              symTab.get(soughtName) match
                case None =>
                  // Not found
                  Seq.empty[Symbols.SymTabItem]
                case Some(list) =>
                  // Get the type of definition we are seeking
                  val tc = classTag[T].runtimeClass

                  // Here is the matching list, if any
                  list.filter { (entry: Symbols.SymTabItem) =>
                    entryWithSameParentsAndType(tc, entry, newParents)
                  }
  }
}
